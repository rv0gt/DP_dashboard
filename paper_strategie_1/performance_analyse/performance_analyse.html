<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper Strategie 1 - Performance Analyse</title>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; line-height: 1.6; color: #333; background-color: #fff; }
        .hero { background: linear-gradient(180deg, #0a2540 0%, #0f3554 100%); padding: 50px 30px 40px; text-align: center; position: relative; overflow: hidden; }
        .hero::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: url('data:image/svg+xml,%3Csvg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="%23ffffff" fill-opacity="0.02"%3E%3Cpath d="M0 40L40 0H20L0 20M40 40V20L20 40"/%3E%3C/g%3E%3C/svg%3E'); background-size: 40px 40px; }
        .hero-content { position: relative; z-index: 1; max-width: 1200px; margin: 0 auto; }
        .breadcrumb { margin-bottom: 20px; }
        .breadcrumb a { color: rgba(255,255,255,0.7); text-decoration: none; font-size: 14px; }
        .breadcrumb a:hover { color: #fff; }
        .breadcrumb span { color: rgba(255,255,255,0.5); margin: 0 10px; }
        .hero h1 { font-size: 36px; font-weight: 300; color: #fff; margin-bottom: 10px; }
        .hero p { color: rgba(255,255,255,0.7); font-size: 16px; }
        .stats-section { background: linear-gradient(180deg, #0f3554 0%, #0a2540 100%); padding: 40px 30px 50px; }
        .stats-grid { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: repeat(5, 1fr); gap: 20px; }
        .stat-card { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); padding: 25px 15px; border-radius: 12px; text-align: center; transition: all 0.3s ease; }
        .stat-card:hover { transform: translateY(-3px); background: rgba(255, 255, 255, 0.08); }
        .stat-number { font-size: 24px; font-weight: 600; color: #fff; margin-bottom: 5px; }
        .stat-label { font-size: 12px; color: rgba(255, 255, 255, 0.7); }
        .positive { color: #4ade80; }
        .negative { color: #f87171; }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 30px; }
        .chart-section { padding: 60px 30px; background: #f8f9fa; }
        .chart-section:nth-child(odd) { background: #fff; }
        .section-title { font-size: 24px; font-weight: 300; color: #333; margin-bottom: 30px; text-align: center; }
        .chart-card { background: #fff; border: 1px solid #e9ecef; border-radius: 12px; padding: 30px; margin-bottom: 30px; }
        .chart-section:nth-child(odd) .chart-card { background: #f8f9fa; }
        .chart-wrapper { height: 350px; position: relative; }
        .chart-controls { display: flex; justify-content: flex-end; gap: 8px; margin-bottom: 10px; }
        .chart-controls button { padding: 6px 12px; font-size: 12px; background: #e5e7eb; color: #374151; border: none; border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .chart-controls button:hover { background: #d1d5db; }
        .chart-hint { font-size: 11px; color: #9ca3af; text-align: center; margin-top: 8px; }
        .chart-title { font-size: 18px; font-weight: 400; margin-bottom: 20px; text-align: center; color: #333; }
        .table-section { padding: 60px 30px; background: #fff; }
        .table-container { background: #fff; border: 1px solid #e9ecef; border-radius: 12px; overflow: auto; }
        table { width: 100%; border-collapse: collapse; }
        th { background: #f8f9fa; padding: 15px 12px; text-align: left; font-size: 13px; font-weight: 600; color: #666; text-transform: uppercase; border-bottom: 2px solid #e9ecef; white-space: nowrap; }
        td { padding: 14px 12px; border-bottom: 1px solid #f0f0f0; font-size: 14px; white-space: nowrap; }
        tr:hover { background: #f8f9fa; }
        tr:last-child td { border-bottom: none; }
        .footer { background: #333; color: #fff; padding: 25px 30px; text-align: center; }
        .footer p { font-size: 13px; color: #999; }
        .last-update { text-align: center; color: #666; font-size: 14px; margin-top: 30px; }
        @media (max-width: 1000px) { .stats-grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 600px) { .stats-grid { grid-template-columns: repeat(2, 1fr); } .hero h1 { font-size: 28px; } .chart-wrapper { height: 280px; } }
    </style>
</head>
<body>
    <section class="hero">
        <div class="hero-content">
            <div class="breadcrumb">
                <a href="../../dashboard_analyse.html">Home</a><span>›</span>
                <a href="../overview.html">Paper Strategie 1</a><span>›</span>
                <span style="color:#fff">Performance Analyse</span>
            </div>
            <h1>Performance Analyse</h1>
            <p>Paper Strategie 1 - Konto-Entwicklung und Kostenanalyse</p>
        </div>
    </section>
    <section class="stats-section">
        <div class="stats-grid" id="metrics">
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Startwert</div></div>
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Aktueller Wert</div></div>
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Rendite</div></div>
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Kum. Kosten</div></div>
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Kum. Slippage</div></div>
        </div>
    </section>
    <section class="chart-section">
        <div class="container">
            <div style="margin-bottom: 40px; text-align: center; padding: 20px; background: #f8f9fa; border-radius: 12px;">
                <div style="display: inline-flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: center;">
                    <label for="dateFilterFrom" style="font-size: 14px; color: #666; font-weight: 500;">Von:</label>
                    <input type="date" id="dateFilterFrom" value="2025-11-28" style="padding: 8px 12px; font-size: 14px; border: 1px solid #ddd; border-radius: 6px; cursor: pointer;">
                    <label for="dateFilterTo" style="font-size: 14px; color: #666; font-weight: 500;">Bis:</label>
                    <input type="date" id="dateFilterTo" style="padding: 8px 12px; font-size: 14px; border: 1px solid #ddd; border-radius: 6px; cursor: pointer;">
                    <button id="applyUnifiedFilter" style="padding: 8px 20px; font-size: 14px; background: #0066cc; color: white; border: none; border-radius: 6px; cursor: pointer;">Anwenden</button>
                    <button id="resetUnifiedFilter" style="padding: 8px 20px; font-size: 14px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer;">Reset</button>
                </div>
            </div>
            <h2 class="section-title">Konto-Entwicklung</h2>
            <div class="chart-card">
                <div class="chart-title">Konto-Wert (absolut in USD)</div>
                <div class="chart-controls"><button onclick="accountValueChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="accountValueChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Konto-Wert (% Veränderung seit Start)</div>
                <div class="chart-controls"><button onclick="accountPctChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="accountPctChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Neuer Hebel (Zeitverlauf)</div>
                <div class="chart-controls"><button onclick="hebelChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="hebelChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Δ Konto vs Δ MES × Hebel (Vergleich)</div>
                <div class="chart-controls"><button onclick="deltaCompareChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="deltaCompareChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
        </div>
    </section>
    <section class="chart-section">
        <div class="container">
            <h2 class="section-title">Kosten pro Kontraktkurs</h2>
            <div class="chart-card">
                <div class="chart-title">Transaktionskosten & Slippage (pro Kontraktkurs)</div>
                <div class="chart-controls"><button onclick="costsChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="costsChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
        </div>
    </section>
    <section class="chart-section">
        <div class="container">
            <h2 class="section-title">Realized P&L (Kumulativ)</h2>
            <div class="chart-card">
                <div class="chart-title">Realized P&L Gross & Net (kumulativ)</div>
                <div class="chart-controls"><button onclick="pnlChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="pnlChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
            <div style="display: flex; justify-content: center; gap: 30px; margin-top: 20px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;"><div style="width: 16px; height: 16px; background: #3b82f6; border-radius: 4px;"></div><span>Realized P&L Gross</span></div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;"><div style="width: 16px; height: 16px; background: #10b981; border-radius: 4px;"></div><span>Realized P&L Net</span></div>
            </div>
        </div>
    </section>
    <section class="table-section">
        <div class="container">
            <h2 class="section-title">Tägliche Übersicht</h2>
            <div class="table-container">
                <table id="history-table">
                    <thead><tr><th>Datum</th><th>Konto-Wert</th><th>Δ Konto</th><th>MES Preis</th><th>Δ MES</th><th>Neuer Hebel</th><th>Δ MES×Hebel (t-1)</th><th>Differenz</th><th>Diff × Konto</th><th>Fees/ Kontraktkurs</th><th>Slippage/ Kontraktkurs</th><th>Kosten/ Kontraktkurs</th><th>Zeitslippage</th></tr></thead>
                    <tbody><tr><td colspan="13" style="text-align:center">Lade Daten...</td></tr></tbody>
                </table>
            </div>
            <div class="last-update" id="last-update"></div>
        </div>
    </section>
    <section class="table-section">
        <div class="container">
            <h2 class="section-title">Transaktionsdetails mit Avg Cost</h2>
            <div class="table-container" style="overflow-x: auto;">
                <table id="transactions-table">
                    <thead><tr><th>Zeitpunkt (CHI)</th><th>Aktion</th><th>Ausgeführt</th><th>Fill-Preis</th><th>Avg Cost (vorher)</th><th>Avg Cost (nachher)</th><th>Realized Gross</th><th>Realized Net</th><th>Status</th></tr></thead>
                    <tbody><tr><td colspan="9" style="text-align:center">Lade Daten...</td></tr></tbody>
                </table>
            </div>
        </div>
    </section>
    <footer class="footer"><p>Paper Strategie 1 - Performance Analyse · Trading Dashboard</p></footer>
    <script>
        // Globale Variable für synchronisiertes Crosshair
        let syncedCharts = [];
        let currentHoverX = null;

        // Crosshair Plugin für vertikale Linie beim Hover - synchronisiert über mehrere Charts
        const syncedCrosshairPlugin = {
            id: 'syncedCrosshair',
            afterDraw: (chart) => {
                if (currentHoverX !== null && syncedCharts.includes(chart)) {
                    const ctx = chart.ctx;
                    const xScale = chart.scales.x;
                    const x = xScale.getPixelForValue(currentHoverX);

                    if (x >= xScale.left && x <= xScale.right) {
                        const topY = chart.scales.y.top;
                        const bottomY = chart.scales.y.bottom;
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, topY);
                        ctx.lineTo(x, bottomY);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        };
        Chart.register(syncedCrosshairPlugin);

        // Gemeinsame Zoom-Optionen für alle Charts - mit funktionierendem Drag und Doppelklick
        const zoomOptions = {
            pan: {
                enabled: true,
                mode: 'x',
                threshold: 5
            },
            zoom: {
                wheel: {
                    enabled: true,
                    speed: 0.1
                },
                pinch: { enabled: true },
                drag: {
                    enabled: false
                },
                mode: 'x'
            },
            limits: {
                x: { minRange: 86400000 }
            }
        };

        const DATA_URL = './performance_analyse.json';
        const OVERVIEW_URL = '../overview.json';
        async function loadJSONData(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP Fehler ${response.status}`);
            return response.json();
        }
        function updateLastUpdate(timestamp, elementId = 'last-update') {
            if (!timestamp) return;
            const el = document.getElementById(elementId);
            if (el) el.innerHTML = `Letzte Aktualisierung: ${new Date(timestamp).toLocaleString('de-DE')}`;
        }
        function parseDate(str) {
            if (!str) return null;
            return new Date(str.replace(' ', 'T'));
        }
        let accountValueChart, accountPctChart, hebelChart, deltaCompareChart, costsChart, pnlChart;
        let fullHistory = [], fullPerfData = null, fullPnlChartData = [];

        async function loadData() {
            try {
                const data = await loadJSONData(DATA_URL);
                const perfData = data.performance_data;
                if (perfData) {
                    fullHistory = perfData.history || [];
                    fullPerfData = perfData;
                    updateMetrics(perfData);
                    const today = new Date().toISOString().split('T')[0];
                    const dateFilterTo = document.getElementById('dateFilterTo');
                    if (dateFilterTo && !dateFilterTo.value) dateFilterTo.value = today;
                    applyUnifiedFilter();
                    updateTable(perfData.history);
                }
                updateLastUpdate(data.timestamp);
                try {
                    const overviewData = await loadJSONData(OVERVIEW_URL);
                    if (overviewData.realized_pnl_chart && overviewData.realized_pnl_chart.length > 0) {
                        fullPnlChartData = overviewData.realized_pnl_chart;
                        initPnlChart(fullPnlChartData);
                        applyUnifiedFilter();
                    }
                    if (overviewData.recent_transactions && overviewData.recent_transactions.length > 0) {
                        updateTransactionsTable(overviewData.recent_transactions);
                    }
                } catch (e) { console.warn('Konnte P&L Chart-Daten nicht laden:', e); }
            } catch (error) { console.error('Fehler:', error); }
        }


        function applyUnifiedFilter() {
            const fromDateInput = document.getElementById('dateFilterFrom');
            const toDateInput = document.getElementById('dateFilterTo');

            if (!fromDateInput || fullHistory.length === 0) return;

            const fromDate = fromDateInput.value;
            const toDate = toDateInput.value;

            let filteredHistory;
            if (!fromDate) {
                filteredHistory = fullHistory;
            } else {
                filteredHistory = fullHistory.filter(h => {
                    const recordDate = h.datum.substring(0, 10);
                    if (recordDate < fromDate) return false;
                    if (toDate && recordDate > toDate) return false;
                    return true;
                });
            }

            if (filteredHistory.length === 0) return;

            const startEntry = filteredHistory[0];
            const startValue = startEntry.konto_wert;
            const startMesPreis = startEntry.mes_preis || 0;
            const startCosts = startEntry.kosten_kumulativ || 0, startSlippage = startEntry.slippage_kumulativ || 0;
            const recalculatedHistory = filteredHistory.map(h => ({
                ...h,
                konto_wert_pct: ((h.konto_wert - startValue) / startValue * 100),
                buy_hold_pct: startMesPreis > 0 ? (((h.mes_preis || 0) - startMesPreis) / startMesPreis * 100) : 0,
                kosten_kumulativ: (h.kosten_kumulativ || 0) - startCosts,
                slippage_kumulativ: (h.slippage_kumulativ || 0) - startSlippage,
                total_kosten_kumulativ: ((h.kosten_kumulativ || 0) - startCosts) + ((h.slippage_kumulativ || 0) - startSlippage),
                kosten_pro_kontrakt: h.kosten_pro_kontrakt,
                slippage_pro_kontrakt: h.slippage_pro_kontrakt,
                total_kosten_pro_kontrakt: h.total_kosten_pro_kontrakt,
                neuer_hebel: h.neuer_hebel
            }));
            updateCharts(recalculatedHistory);
            if (pnlChart && fullPnlChartData.length > 0) {
                let filteredPnlData;
                if (!fromDate) {
                    filteredPnlData = fullPnlChartData;
                } else {
                    filteredPnlData = fullPnlChartData.filter(d => {
                        if (d.date < fromDate) return false;
                        if (toDate && d.date > toDate) return false;
                        return true;
                    });
                }
                let cumGross = 0, cumNet = 0;
                const recalcPnl = filteredPnlData.map(d => {
                    cumGross += d.daily_gross || 0;
                    cumNet += d.daily_net || 0;
                    return { ...d, cumulative_gross: cumGross, cumulative_net: cumNet };
                });
                pnlChart.data.datasets[0].data = recalcPnl.map(d => ({ x: parseDate(d.date), y: d.cumulative_gross }));
                pnlChart.data.datasets[1].data = recalcPnl.map(d => ({ x: parseDate(d.date), y: d.cumulative_net }));
                pnlChart.update();
            }
        }
        function resetUnifiedFilter() {
            const fromDateInput = document.getElementById('dateFilterFrom');
            const toDateInput = document.getElementById('dateFilterTo');
            if (fromDateInput) fromDateInput.value = '2025-11-28';
            if (toDateInput) toDateInput.value = new Date().toISOString().split('T')[0];
            applyUnifiedFilter();
        }
        function formatCurrency(num, decimals = 0) {
            if (num === null || num === undefined) return '—';
            return new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'USD', minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(num);
        }
        function initPnlChart(chartData) {
            fullPnlChartData = chartData;
            const ctx = document.getElementById('pnlChart');
            if (!ctx) return;
            if (pnlChart) pnlChart.destroy();
            pnlChart = new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                        { label: 'Realized P&L Gross (Kumulativ)', data: chartData.map(d => ({ x: parseDate(d.date), y: d.cumulative_gross })), borderColor: '#3b82f6', backgroundColor: 'rgba(59, 130, 246, 0.1)', fill: true, tension: 0, pointRadius: 2, pointHoverRadius: 6 },
                        { label: 'Realized P&L Net (Kumulativ)', data: chartData.map(d => ({ x: parseDate(d.date), y: d.cumulative_net })), borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.1)', fill: true, tension: 0, pointRadius: 2, pointHoverRadius: 6 }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: { callbacks: { title: ctx => new Date(ctx[0].parsed.x).toLocaleDateString('de-DE'), label: ctx => `${ctx.dataset.label}: ${formatCurrency(ctx.parsed.y, 2)}` } },
                        zoom: zoomOptions
                    },
                    scales: {
                        x: { type: 'time', time: { displayFormats: { day: 'dd.MM.yy', hour: 'dd.MM HH:mm' }, tooltipFormat: 'dd.MM.yyyy HH:mm:ss' }, grid: { display: false } },
                        y: { ticks: { callback: v => '$' + v.toLocaleString('de-DE') }, grid: { color: 'rgba(0, 0, 0, 0.05)' } }
                    }
                }
            });

            // Doppelklick zum Reset
            ctx.ondblclick = () => pnlChart?.resetZoom();
        }
        function updateMetrics(perfData) {
            if (!perfData) return;
            const metricsEl = document.getElementById('metrics');
            if (!metricsEl) return;
            const returnPct = parseFloat(perfData.total_return_pct || 0);
            const returnClass = returnPct >= 0 ? 'positive' : 'negative';
            const ibIndicator = perfData.current_value_from_ib ? '<span style="font-size: 10px; color: #4ade80; margin-left: 5px;">● IB</span>' : '<span style="font-size: 10px; color: #999; margin-left: 5px;">● DB</span>';
            metricsEl.innerHTML = `
                <div class="stat-card"><div class="stat-number">${formatCurrency(perfData.start_value)}</div><div class="stat-label">Startwert</div></div>
                <div class="stat-card"><div class="stat-number">${formatCurrency(perfData.current_value)}${ibIndicator}</div><div class="stat-label">Aktueller Wert</div></div>
                <div class="stat-card"><div class="stat-number ${returnClass}">${returnPct >= 0 ? '+' : ''}${returnPct.toFixed(2)}%</div><div class="stat-label">Rendite</div></div>
                <div class="stat-card"><div class="stat-number negative">${formatCurrency(perfData.total_costs)}</div><div class="stat-label">Kum. Kosten</div></div>
                <div class="stat-card"><div class="stat-number negative">${formatCurrency(perfData.total_slippage)}</div><div class="stat-label">Kum. Slippage</div></div>`;
        }

        // Funktion um synchronisiertes Hover zu handhaben
        function setupSyncedHover(chart) {
            chart.canvas.addEventListener('mousemove', (e) => {
                const rect = chart.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const xScale = chart.scales.x;
                if (x >= xScale.left && x <= xScale.right) {
                    currentHoverX = xScale.getValueForPixel(x);
                    syncedCharts.forEach(c => {
                        if (c !== chart) c.update('none');
                    });
                }
            });
            chart.canvas.addEventListener('mouseleave', () => {
                currentHoverX = null;
                syncedCharts.forEach(c => c.update('none'));
            });
        }

        function updateCharts(history) {
            if (!history || history.length === 0) return;
            const sorted = [...history].sort((a, b) => parseDate(a.datum) - parseDate(b.datum));
            const timeOpts = { type: 'time', time: { displayFormats: { day: 'dd.MM.yy', hour: 'dd.MM HH:mm' }, tooltipFormat: 'dd.MM.yyyy HH:mm:ss' }, grid: { color: '#f0f0f0' } };

            // Reset synced charts array
            syncedCharts = [];

            // Chart 1: Konto-Wert absolut
            const ctx1 = document.getElementById('accountValueChart').getContext('2d');
            if (accountValueChart) accountValueChart.destroy();
            accountValueChart = new Chart(ctx1, {
                type: 'line',
                data: { datasets: [{ label: 'Konto-Wert (USD)', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.konto_wert })), borderColor: '#0066cc', backgroundColor: 'rgba(0, 102, 204, 0.1)', fill: true, tension: 0, pointRadius: 4, pointHoverRadius: 8, pointBackgroundColor: '#0066cc' }] },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'top' }, zoom: zoomOptions }, scales: { x: timeOpts, y: { grid: { color: '#f0f0f0' }, ticks: { callback: v => '$' + (v/1000).toFixed(0) + 'k' } } } }
            });
            document.getElementById('accountValueChart').ondblclick = () => accountValueChart?.resetZoom();

            // Chart 2: Konto-Wert % - wird synchronisiert mit Hebel
            const ctx2 = document.getElementById('accountPctChart').getContext('2d');
            if (accountPctChart) accountPctChart.destroy();
            const lastPct = sorted[sorted.length - 1].konto_wert_pct;
            accountPctChart = new Chart(ctx2, {
                type: 'line',
                data: { datasets: [
                    { label: 'Strategie (%)', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.konto_wert_pct })), borderColor: lastPct >= 0 ? '#4ade80' : '#f87171', backgroundColor: lastPct >= 0 ? 'rgba(74, 222, 128, 0.1)' : 'rgba(248, 113, 113, 0.1)', fill: true, tension: 0, pointRadius: 4, pointHoverRadius: 8, borderWidth: 2 },
                    { label: 'Buy & Hold MES (%)', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.buy_hold_pct || 0 })), borderColor: '#0066cc', backgroundColor: 'rgba(0, 102, 204, 0.1)', fill: false, tension: 0, pointRadius: 3, pointHoverRadius: 7, borderWidth: 2, borderDash: [5, 5] }
                ] },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'top' }, zoom: zoomOptions }, scales: { x: timeOpts, y: { grid: { color: '#f0f0f0' }, ticks: { callback: v => v.toFixed(2) + '%' } } } }
            });
            document.getElementById('accountPctChart').ondblclick = () => accountPctChart?.resetZoom();
            syncedCharts.push(accountPctChart);
            setupSyncedHover(accountPctChart);

            // Chart 3: Hebel - synchronisiert mit Konto-Wert %
            const ctx3 = document.getElementById('hebelChart').getContext('2d');
            if (hebelChart) hebelChart.destroy();
            hebelChart = new Chart(ctx3, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Neuer Hebel',
                            data: sorted.map(h => ({ x: parseDate(h.datum), y: h.neuer_hebel })).filter(p => p.y !== null),
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            fill: true,
                            tension: 0,
                            pointRadius: 3,
                            borderWidth: 2,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Verhältnis Δ Strategie / Δ Buy&Hold',
                            data: sorted.map((h, idx) => {
                                if (idx === 0) return { x: parseDate(h.datum), y: null };

                                const prevKontoWert = sorted[idx - 1].konto_wert || 0;
                                const currKontoWert = h.konto_wert || 0;
                                const prevMesPreis = sorted[idx - 1].mes_preis || 0;
                                const currMesPreis = h.mes_preis || 0;

                                const deltaStrategie = prevKontoWert !== 0 ? ((currKontoWert - prevKontoWert) / prevKontoWert * 100) : 0;
                                const deltaBuyHold = prevMesPreis !== 0 ? ((currMesPreis - prevMesPreis) / prevMesPreis * 100) : 0;

                                const ratio = deltaBuyHold !== 0 ? (deltaStrategie / deltaBuyHold) : null;

                                return { x: parseDate(h.datum), y: ratio };
                            }).filter(p => p.y !== null),
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.1)',
                            fill: false,
                            tension: 0,
                            pointRadius: 3,
                            borderWidth: 2,
                            borderDash: [5, 5],
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { position: 'top' }, zoom: zoomOptions },
                    scales: {
                        x: timeOpts,
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: { color: '#f0f0f0' },
                            ticks: { callback: v => v.toFixed(2) + 'x' },
                            title: { display: true, text: 'Hebel' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: { drawOnChartArea: false },
                            ticks: { callback: v => v.toFixed(2) + 'x' },
                            title: { display: true, text: 'Verhältnis Δ Performance' }
                        }
                    }
                }
            });
            document.getElementById('hebelChart').ondblclick = () => hebelChart?.resetZoom();
            syncedCharts.push(hebelChart);
            setupSyncedHover(hebelChart);

            // Chart 4: Delta Vergleich - Δ Konto vs Δ MES × Hebel
            const ctx4Compare = document.getElementById('deltaCompareChart').getContext('2d');
            if (deltaCompareChart) deltaCompareChart.destroy();

            // Berechne Δ Konto, Δ MES × Hebel und Differenz
            const deltaData = sorted.map((h, idx) => {
                if (idx === 0) return null;

                const prev = sorted[idx - 1];
                const prevKonto = prev.konto_wert || 0;
                const currKonto = h.konto_wert || 0;
                const prevMes = prev.mes_preis || 0;
                const currMes = h.mes_preis || 0;
                const hebel = prev.neuer_hebel || 0; // Hebel t-1

                const deltaKontoPct = prevKonto !== 0 ? ((currKonto - prevKonto) / prevKonto * 100) : 0;
                const deltaMesPct = prevMes !== 0 ? ((currMes - prevMes) / prevMes * 100) : 0;
                const deltaMesHebelPct = deltaMesPct * hebel;
                const differenz = deltaKontoPct - deltaMesHebelPct;

                return {
                    x: parseDate(h.datum),
                    deltaKonto: deltaKontoPct,
                    deltaMesHebel: deltaMesHebelPct,
                    differenz: differenz
                };
            }).filter(d => d !== null);

            deltaCompareChart = new Chart(ctx4Compare, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Δ Konto (%)',
                            data: deltaData.map(d => ({ x: d.x, y: d.deltaKonto })),
                            borderColor: '#4ade80',
                            backgroundColor: 'rgba(74, 222, 128, 0.1)',
                            fill: false,
                            tension: 0,
                            pointRadius: 3,
                            borderWidth: 2,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Δ MES × Hebel (%)',
                            data: deltaData.map(d => ({ x: d.x, y: d.deltaMesHebel })),
                            borderColor: '#0066cc',
                            backgroundColor: 'rgba(0, 102, 204, 0.1)',
                            fill: false,
                            tension: 0,
                            pointRadius: 3,
                            borderWidth: 2,
                            borderDash: [5, 5],
                            yAxisID: 'y'
                        },
                        {
                            label: 'Differenz (%)',
                            data: deltaData.map(d => ({ x: d.x, y: d.differenz })),
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.2)',
                            fill: true,
                            tension: 0,
                            pointRadius: 2,
                            borderWidth: 2,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { position: 'top' },
                        zoom: zoomOptions,
                        tooltip: {
                            callbacks: {
                                label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(4)}%`
                            }
                        }
                    },
                    scales: {
                        x: timeOpts,
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: { color: '#f0f0f0' },
                            ticks: { callback: v => v.toFixed(2) + '%' },
                            title: { display: true, text: 'Δ Konto / Δ MES×Hebel' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: { drawOnChartArea: false },
                            ticks: { callback: v => v.toFixed(2) + '%' },
                            title: { display: true, text: 'Differenz' }
                        }
                    }
                }
            });
            document.getElementById('deltaCompareChart').ondblclick = () => deltaCompareChart?.resetZoom();
            syncedCharts.push(deltaCompareChart);
            setupSyncedHover(deltaCompareChart);

            // Chart 5: Kosten
            const ctx5 = document.getElementById('costsChart').getContext('2d');
            if (costsChart) costsChart.destroy();
            costsChart = new Chart(ctx5, {
                type: 'line',
                data: { datasets: [
                    { label: 'Transaktionskosten / Kontrakt', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.kosten_pro_kontrakt })).filter(p => p.y > 0), borderColor: '#f87171', backgroundColor: 'rgba(248, 113, 113, 0.1)', fill: true, tension: 0, pointRadius: 3, pointHoverRadius: 7 },
                    { label: 'Slippage / Kontrakt', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.slippage_pro_kontrakt })).filter(p => p.y > 0), borderColor: '#fbbf24', backgroundColor: 'rgba(251, 191, 36, 0.1)', fill: true, tension: 0, pointRadius: 3, pointHoverRadius: 7 },
                    { label: 'Total / Kontrakt', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.total_kosten_pro_kontrakt })).filter(p => p.y > 0), borderColor: '#8b5cf6', borderWidth: 2, borderDash: [5, 5], fill: false, tension: 0, pointRadius: 4, pointHoverRadius: 8 }
                ] },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'top' }, zoom: zoomOptions }, scales: { x: timeOpts, y: { grid: { color: '#f0f0f0' }, ticks: { callback: v => '$' + v.toFixed(2) } } } }
            });
            document.getElementById('costsChart').ondblclick = () => costsChart?.resetZoom();
        }

        function updateTable(history) {
            const tbody = document.querySelector('#history-table tbody');
            if (!history || history.length === 0) { tbody.innerHTML = '<tr><td colspan="13" style="text-align:center">Keine Daten</td></tr>'; return; }
            const reversed = [...history].reverse();
            tbody.innerHTML = reversed.map((h, idx) => {
                const hebel = h.neuer_hebel !== null && h.neuer_hebel !== undefined ? h.neuer_hebel.toFixed(3) + 'x' : '—';
                const kostenProKontraktVal = h.kosten_pro_kontrakt > 0 ? h.kosten_pro_kontrakt : 0;
                const slippageProKontraktVal = h.slippage_pro_kontrakt > 0 ? h.slippage_pro_kontrakt : 0;
                const totalProKontraktVal = kostenProKontraktVal + slippageProKontraktVal;
                const kostenProKontrakt = kostenProKontraktVal > 0 ? '$' + kostenProKontraktVal.toFixed(4) : '—';
                const slippageProKontrakt = slippageProKontraktVal > 0 ? '$' + slippageProKontraktVal.toFixed(4) : '—';
                const totalProKontrakt = totalProKontraktVal > 0 ? '$' + totalProKontraktVal.toFixed(4) : '—';
                const mesPreis = h.mes_preis ? '$' + h.mes_preis.toFixed(2) : '—';

                // Berechne Deltas
                let deltaKonto = '—', deltaMes = '—', deltaMesHebel = '—', differenz = '—', diffKonto = '—';
                let deltaKontoClass = '', deltaMesClass = '', deltaMesHebelClass = '', differenzClass = '', diffKontoClass = '';
                let deltaKontoPctVal = 0, deltaMesPctVal = 0, deltaMesHebelPctVal = 0, differenzVal = 0;

                // Wir brauchen den zeitlich früheren Wert (nächster in reversed array)
                if (idx < reversed.length - 1) {
                    const prev = reversed[idx + 1]; // Zeitlich früher
                    const prevKonto = prev.konto_wert || 0;
                    const currKonto = h.konto_wert || 0;
                    const prevMes = prev.mes_preis || 0;
                    const currMes = h.mes_preis || 0;
                    const prevHebel = prev.neuer_hebel || 0; // Hebel t-1 für Berechnung

                    if (prevKonto > 0) {
                        deltaKontoPctVal = ((currKonto - prevKonto) / prevKonto * 100);
                        deltaKontoClass = deltaKontoPctVal >= 0 ? 'positive' : 'negative';
                        deltaKonto = (deltaKontoPctVal >= 0 ? '+' : '') + deltaKontoPctVal.toFixed(2) + '%';
                    }

                    if (prevMes > 0) {
                        deltaMesPctVal = ((currMes - prevMes) / prevMes * 100);
                        deltaMesClass = deltaMesPctVal >= 0 ? 'positive' : 'negative';
                        deltaMes = (deltaMesPctVal >= 0 ? '+' : '') + deltaMesPctVal.toFixed(2) + '%';

                        // Δ MES × Hebel
                        deltaMesHebelPctVal = deltaMesPctVal * prevHebel;
                        deltaMesHebelClass = deltaMesHebelPctVal >= 0 ? 'positive' : 'negative';
                        deltaMesHebel = (deltaMesHebelPctVal >= 0 ? '+' : '') + deltaMesHebelPctVal.toFixed(2) + '%';
                    }

                    // Differenz = Δ Konto - Δ MES × Hebel
                    if (prevKonto > 0 && prevMes > 0) {
                        differenzVal = deltaKontoPctVal - deltaMesHebelPctVal;
                        differenzClass = differenzVal >= 0 ? 'positive' : 'negative';
                        differenz = (differenzVal >= 0 ? '+' : '') + differenzVal.toFixed(4) + '%';

                        // Differenz × Kontowert
                        const diffKontoVal = (differenzVal / 100) * currKonto;
                        diffKontoClass = diffKontoVal >= 0 ? 'positive' : 'negative';
                        diffKonto = formatCurrency(diffKontoVal, 2);
                    }
                }

                // Farbe für Total/Kontraktkurs: rot wenn > $0.38, orange wenn > $0.25
                const totalStyle = totalProKontraktVal > 0.38 ? 'class="negative"' : (totalProKontraktVal > 0.25 ? 'style="color: #f97316;"' : '');

                // Zeitslippage: positiv = grün (gut), negativ = rot (schlecht)
                const zeitslippageVal = h.zeitslippage;
                let zeitslippage = '—';
                let zeitslippageClass = '';
                if (zeitslippageVal !== null && zeitslippageVal !== undefined) {
                    zeitslippageClass = zeitslippageVal >= 0 ? 'positive' : 'negative';
                    zeitslippage = (zeitslippageVal >= 0 ? '+' : '') + '$' + Math.abs(zeitslippageVal).toFixed(4);
                }

                return `<tr><td>${h.datum}</td><td>${formatCurrency(h.konto_wert)}</td><td class="${deltaKontoClass}">${deltaKonto}</td><td>${mesPreis}</td><td class="${deltaMesClass}">${deltaMes}</td><td>${hebel}</td><td class="${deltaMesHebelClass}">${deltaMesHebel}</td><td class="${differenzClass}">${differenz}</td><td class="${diffKontoClass}">${diffKonto}</td><td>${kostenProKontrakt}</td><td>${slippageProKontrakt}</td><td ${totalStyle}>${totalProKontrakt}</td><td class="${zeitslippageClass}">${zeitslippage}</td></tr>`;
            }).join('');
        }

        function updateTransactionsTable(transactions) {
            const tbody = document.querySelector('#transactions-table tbody');
            if (!transactions || transactions.length === 0) { tbody.innerHTML = '<tr><td colspan="9" style="text-align:center">Keine Transaktionen</td></tr>'; return; }
            tbody.innerHTML = transactions.map(t => {
                const formatPnlCell = (val) => {
                    if (val === null || val === undefined) return '—';
                    const num = parseFloat(val);
                    const cls = num >= 0 ? 'positive' : 'negative';
                    return `<span class="${cls}">${formatCurrency(num, 2)}</span>`;
                };
                return `<tr>
                    <td>${new Date(t.date_chi).toLocaleString('de-DE')}</td>
                    <td><strong>${t.aktion || '—'}</strong></td>
                    <td style="text-align:right">${t.ausgefuehrte_menge ?? '—'}</td>
                    <td style="text-align:right">${t.durchschnittspreis ? '$' + parseFloat(t.durchschnittspreis).toFixed(2) : '—'}</td>
                    <td style="text-align:right">${t.avg_position_cost_before ? '$' + parseFloat(t.avg_position_cost_before).toFixed(2) : '—'}</td>
                    <td style="text-align:right">${t.avg_position_cost ? '$' + parseFloat(t.avg_position_cost).toFixed(2) : '—'}</td>
                    <td style="text-align:right">${formatPnlCell(t.realized_pnl_gross)}</td>
                    <td style="text-align:right">${formatPnlCell(t.realized_pnl_net)}</td>
                    <td>${t.status || '—'}</td>
                </tr>`;
            }).join('');
        }
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('applyUnifiedFilter')?.addEventListener('click', applyUnifiedFilter);
            document.getElementById('resetUnifiedFilter')?.addEventListener('click', resetUnifiedFilter);
            document.getElementById('dateFilterFrom')?.addEventListener('change', applyUnifiedFilter);
            document.getElementById('dateFilterTo')?.addEventListener('change', applyUnifiedFilter);
            const toDateInput = document.getElementById('dateFilterTo');
            if (toDateInput && !toDateInput.value) toDateInput.value = new Date().toISOString().split('T')[0];
        });
        loadData();
        setInterval(loadData, 60000);
    </script>
</body>
</html>
