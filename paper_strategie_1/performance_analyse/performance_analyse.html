<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper Strategie 1 - Performance Analyse</title>
    <!-- Shared CSS and JS -->
    <link rel="stylesheet" href="../../_shared/css/common.css">
    <script src="../../_shared/js/includes.js"></script>
    <!-- Chart.js Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        /* Page-specific styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; line-height: 1.6; color: #333; background-color: #fff; }
        .hero { background: linear-gradient(135deg, #0a2540 0%, #0d3a5c 50%, #134e7a 100%); padding: 0; text-align: center; min-height: 28vh; display: flex; flex-direction: column; position: relative; overflow: hidden; }
        .hero::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse 80% 50% at 50% -20%, rgba(0, 102, 204, 0.3), transparent), radial-gradient(ellipse 60% 40% at 100% 100%, rgba(0, 163, 255, 0.15), transparent), url('data:image/svg+xml,%3Csvg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="%23ffffff" fill-opacity="0.02"%3E%3Cpath d="M0 40L40 0H20L0 20M40 40V20L20 40"/%3E%3C/g%3E%3C/svg%3E'); background-size: auto, auto, 40px 40px; animation: subtleFloat 20s ease-in-out infinite; }
        @keyframes subtleFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .hero::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 100px; background: linear-gradient(to top, rgba(10, 37, 64, 0.8), transparent); pointer-events: none; }
        .hero-content { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 50px 30px 40px; position: relative; z-index: 1; max-width: 1200px; margin: 0 auto; width: 100%; }
        .breadcrumb { margin-bottom: 20px; }
        .breadcrumb a { color: rgba(255,255,255,0.7); text-decoration: none; font-size: 14px; }
        .breadcrumb a:hover { color: #fff; }
        .breadcrumb span { color: rgba(255,255,255,0.5); margin: 0 10px; }
        .hero h1 { font-size: 42px; font-weight: 300; color: #fff; margin-bottom: 10px; line-height: 1.1; letter-spacing: -0.5px; }
        .hero p { color: rgba(255,255,255,0.7); font-size: 18px; }
        .stats-section { background: linear-gradient(180deg, #0f3554 0%, #0a2540 100%); padding: 40px 30px 50px; }
        .stats-grid { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: repeat(5, 1fr); gap: 20px; }
        .stat-card { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); padding: 25px 15px; border-radius: 12px; text-align: center; transition: all 0.3s ease; }
        .stat-card:hover { transform: translateY(-3px); background: rgba(255, 255, 255, 0.08); }
        .stat-number { font-size: 24px; font-weight: 600; color: #fff; margin-bottom: 5px; }
        .stat-label { font-size: 12px; color: rgba(255, 255, 255, 0.7); }
        .positive { color: #4ade80; }
        .negative { color: #f87171; }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 30px; transition: max-width 0.3s ease; }
        .container.fullwidth { max-width: 100%; padding: 0 15px; }
        .control-btn { padding: 8px 16px; background: #0066cc; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; text-transform: uppercase; transition: all 0.2s ease; display: flex; align-items: center; gap: 6px; }
        .control-btn:hover { background: #0052a3; transform: translateY(-1px); }
        .control-btn.active { background: #10b981; }
        .fullwidth-controls { display: flex; justify-content: flex-end; margin-bottom: 15px; }
        .chart-section { padding: 60px 30px; background: #f8f9fa; }
        .chart-section:nth-child(odd) { background: #fff; }
        .section-title { font-size: 24px; font-weight: 300; color: #333; margin-bottom: 30px; text-align: center; }
        .chart-card { background: #fff; border: 1px solid #e9ecef; border-radius: 12px; padding: 30px; margin-bottom: 30px; }
        .chart-section:nth-child(odd) .chart-card { background: #f8f9fa; }
        .chart-wrapper { height: 350px; position: relative; }
        .chart-controls { display: flex; justify-content: flex-end; gap: 8px; margin-bottom: 10px; }
        .chart-controls button { padding: 6px 12px; font-size: 12px; background: #e5e7eb; color: #374151; border: none; border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .chart-controls button:hover { background: #d1d5db; }
        .chart-hint { font-size: 11px; color: #9ca3af; text-align: center; margin-top: 8px; }
        .chart-title { font-size: 18px; font-weight: 400; margin-bottom: 20px; text-align: center; color: #333; }
        .table-section { padding: 60px 30px; background: #fff; }
        .table-container { background: #fff; border: 1px solid #e9ecef; border-radius: 12px; overflow: auto; }
        table { width: 100%; border-collapse: collapse; }
        th { background: #f8f9fa; padding: 15px 12px; text-align: left; font-size: 13px; font-weight: 600; color: #666; text-transform: uppercase; border-bottom: 2px solid #e9ecef; white-space: nowrap; }
        td { padding: 14px 12px; border-bottom: 1px solid #f0f0f0; font-size: 14px; white-space: nowrap; }
        tr:hover { background: #f8f9fa; }
        tr:last-child td { border-bottom: none; }
        .footer { background: #333; color: #fff; padding: 25px 30px; text-align: center; }
        .footer p { font-size: 13px; color: #999; }
        .last-update { text-align: center; color: #666; font-size: 14px; margin-top: 30px; }
        @media (max-width: 1000px) { .stats-grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 600px) { .stats-grid { grid-template-columns: repeat(2, 1fr); } .hero h1 { font-size: 28px; } .chart-wrapper { height: 280px; } }

        /* Navigation and breadcrumb styles from common.css */
    </style>
</head>
<body>
    <div id="nav-placeholder"></div>
    <section class="hero">
        <div class="hero-content">
            <div class="breadcrumb">
                <a href="../../dashboard_analyse.html">Home</a>
                <span class="breadcrumb-separator">›</span>
                <a href="../overview.html">Paper Strategie 1</a>
                <span class="breadcrumb-separator">›</span>
                <span class="breadcrumb-current">Performance Analyse</span>
            </div>
            <h1>Performance Analyse</h1>
            <p>Paper Strategie 1 - Konto-Entwicklung und Kostenanalyse</p>
        </div>
    </section>
    <section class="stats-section">
        <div class="stats-grid" id="metrics">
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Startwert</div></div>
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Aktueller Wert</div></div>
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Rendite</div></div>
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Kum. Kosten</div></div>
            <div class="stat-card"><div class="stat-number">—</div><div class="stat-label">Kum. Slippage</div></div>
        </div>
    </section>
    <section class="chart-section">
        <div class="container">
            <div style="margin-bottom: 40px; text-align: center; padding: 20px; background: #f8f9fa; border-radius: 12px;">
                <div style="display: inline-flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: center;">
                    <label for="dateFilterFrom" style="font-size: 14px; color: #666; font-weight: 500;">Von:</label>
                    <input type="date" id="dateFilterFrom" value="2025-11-28" style="padding: 8px 12px; font-size: 14px; border: 1px solid #ddd; border-radius: 6px; cursor: pointer;">
                    <label for="dateFilterTo" style="font-size: 14px; color: #666; font-weight: 500;">Bis:</label>
                    <input type="date" id="dateFilterTo" style="padding: 8px 12px; font-size: 14px; border: 1px solid #ddd; border-radius: 6px; cursor: pointer;">
                    <button id="applyUnifiedFilter" style="padding: 8px 20px; font-size: 14px; background: #0066cc; color: white; border: none; border-radius: 6px; cursor: pointer;">Anwenden</button>
                    <button id="resetUnifiedFilter" style="padding: 8px 20px; font-size: 14px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer;">Reset</button>
                </div>
            </div>
            <h2 class="section-title">Konto-Entwicklung</h2>
            <div class="chart-card">
                <div class="chart-title">Konto-Wert (absolut in USD)</div>
                <div class="chart-controls"><button onclick="accountValueChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="accountValueChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Konto-Wert (% Veränderung seit Start) mit Hebel</div>
                <div class="chart-controls"><button onclick="accountPctChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="accountPctChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Δ Konto vs Δ MES × Hebel (Vergleich)</div>
                <div class="chart-controls"><button onclick="deltaCompareChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="deltaCompareChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
        </div>
    </section>
    <section class="chart-section">
        <div class="container">
            <h2 class="section-title">Kosten pro Kontraktkurs</h2>
            <div class="chart-card">
                <div class="chart-title">Transaktionskosten & Slippage (pro Kontraktkurs)</div>
                <div class="chart-controls"><button onclick="costsChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="costsChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
        </div>
    </section>
    <section class="chart-section">
        <div class="container">
            <h2 class="section-title">Performance</h2>
            <div class="chart-card">
                <div class="chart-title">Unrealized P&L + Kumulativ Realized P&L + Kumulativ Transaktionskosten</div>
                <div class="chart-controls"><button onclick="performanceChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="performanceChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
            <div style="display: flex; justify-content: center; gap: 30px; margin-top: 20px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;"><div style="width: 16px; height: 16px; background: #0066cc; border-radius: 4px;"></div><span>Performance (Summe)</span></div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;"><div style="width: 16px; height: 16px; background: #8b5cf6; border-radius: 4px;"></div><span>Unrealized P&L</span></div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;"><div style="width: 16px; height: 16px; background: #10b981; border-radius: 4px;"></div><span>Kumulativ Realized P&L Net</span></div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;"><div style="width: 16px; height: 16px; background: #f87171; border-radius: 4px;"></div><span>Kumulativ Transaktionskosten</span></div>
            </div>
        </div>
    </section>
    <section class="chart-section">
        <div class="container">
            <h2 class="section-title">Realized P&L (Kumulativ)</h2>
            <div class="chart-card">
                <div class="chart-title">Realized P&L Gross & Net (kumulativ)</div>
                <div class="chart-controls"><button onclick="pnlChart?.resetZoom()">Reset Zoom</button></div>
                <div class="chart-wrapper"><canvas id="pnlChart"></canvas></div>
                <div class="chart-hint">Mausrad zum Zoomen | Ziehen zum Verschieben | Doppelklick zum Reset</div>
            </div>
            <div style="display: flex; justify-content: center; gap: 30px; margin-top: 20px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;"><div style="width: 16px; height: 16px; background: #3b82f6; border-radius: 4px;"></div><span>Realized P&L Gross</span></div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: #666;"><div style="width: 16px; height: 16px; background: #10b981; border-radius: 4px;"></div><span>Realized P&L Net</span></div>
            </div>
        </div>
    </section>
    <section class="table-section">
        <div class="container" id="table-container">
            <h2 class="section-title">Tägliche Übersicht</h2>
            <div class="fullwidth-controls">
                <button class="control-btn" id="fullwidth-btn" onclick="toggleFullwidth()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                    </svg>
                    Vollbild
                </button>
            </div>
            <div class="table-container">
                <table id="history-table">
                    <thead><tr><th>Datum</th><th>Konto-Wert</th><th>Δ Konto</th><th>MES Preis</th><th>Δ MES</th><th>Neuer Hebel</th><th>Δ MES×Hebel (t-1)</th><th>Differenz</th><th>Diff × Konto</th><th>Fees/ Kontraktkurs</th><th>Slippage/ Kontraktkurs</th><th>Kosten/ Kontraktkurs</th><th>Zeitslippage</th></tr></thead>
                    <tbody><tr><td colspan="13" style="text-align:center">Lade Daten...</td></tr></tbody>
                </table>
            </div>
            <div class="last-update" id="last-update"></div>
        </div>
    </section>
    <section class="table-section">
        <div class="container">
            <h2 class="section-title">Transaktionsdetails mit Avg Cost</h2>
            <div class="table-container" style="overflow-x: auto;">
                <table id="transactions-table">
                    <thead><tr><th>Zeitpunkt (CHI)</th><th>Aktion</th><th>Ausgeführt</th><th>Fill-Preis</th><th>Avg Cost (vorher)</th><th>Avg Cost (nachher)</th><th>Realized Gross</th><th>Realized Net</th><th>Status</th></tr></thead>
                    <tbody><tr><td colspan="9" style="text-align:center">Lade Daten...</td></tr></tbody>
                </table>
            </div>
        </div>
    </section>
    <footer class="footer"><p>Paper Strategie 1 - Performance Analyse · Trading Dashboard</p></footer>
    <script>
        // Fullwidth Toggle
        let isFullwidth = false;
        function toggleFullwidth() {
            const container = document.getElementById('table-container');
            const btn = document.getElementById('fullwidth-btn');
            isFullwidth = !isFullwidth;
            if (isFullwidth) {
                container.classList.add('fullwidth');
                btn.classList.add('active');
                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 14h6m0 0v6m0-6L3 21M20 10h-6m0 0V4m0 6l7-7"/></svg> Normal`;
            } else {
                container.classList.remove('fullwidth');
                btn.classList.remove('active');
                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg> Vollbild`;
            }
        }
    </script>
    <script>
        // Globale Variable für synchronisiertes Crosshair
        let syncedCharts = [];
        let currentHoverX = null;

        // Crosshair Plugin für vertikale Linie beim Hover - synchronisiert über mehrere Charts
        const syncedCrosshairPlugin = {
            id: 'syncedCrosshair',
            afterDraw: (chart) => {
                if (currentHoverX !== null && syncedCharts.includes(chart)) {
                    const ctx = chart.ctx;
                    const xScale = chart.scales.x;
                    const x = xScale.getPixelForValue(currentHoverX);

                    if (x >= xScale.left && x <= xScale.right) {
                        const topY = chart.scales.y.top;
                        const bottomY = chart.scales.y.bottom;
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, topY);
                        ctx.lineTo(x, bottomY);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        };
        Chart.register(syncedCrosshairPlugin);

        // Gemeinsame Zoom-Optionen für alle Charts
        // deltaY (Mausrad drehen) = Zoom, deltaX (Mausrad kippen) = Panning
        const zoomOptions = {
            pan: {
                enabled: true,
                mode: 'x',
                threshold: 5
            },
            zoom: {
                wheel: {
                    enabled: true // Mausrad-Zoom aktiviert (deltaY)
                },
                pinch: { enabled: true },
                drag: {
                    enabled: false
                },
                mode: 'x'
            },
            limits: {
                x: { minRange: 86400000 }
            }
        };

        // Zoom-Optionen für accountPctChart mit onPan/onZoom-Callback
        const zoomOptionsPct = {
            pan: {
                enabled: true,
                mode: 'x',
                threshold: 5,
                onPan: function() {
                    recalculatePctFromVisibleRange();
                }
            },
            zoom: {
                wheel: {
                    enabled: true // Mausrad-Zoom aktiviert (deltaY)
                },
                pinch: { enabled: true },
                drag: {
                    enabled: false
                },
                mode: 'x',
                onZoom: function() {
                    recalculatePctFromVisibleRange();
                }
            },
            limits: {
                x: { minRange: 86400000 }
            }
        };

        // Funktion um horizontales Mausrad-Kippen für Panning zu nutzen
        // deltaX (Mausrad nach rechts/links kippen) = NUR Panning (kein Zoom)
        // deltaY (Mausrad drehen) = Zoom (vom Chart.js Zoom-Plugin behandelt)
        function setupWheelPan(chart, onPanCallback) {
            // Event-Listener mit capture: true, damit er VOR dem Zoom-Plugin ausgeführt wird
            chart.canvas.addEventListener('wheel', (e) => {
                const xScale = chart.scales.x;
                if (!xScale) return;

                // NUR horizontales Mausrad (deltaX) für Panning verwenden
                // deltaX kommt vom Kippen des Mausrads nach rechts/links
                if (e.deltaX !== 0) {
                    // Stoppe Event komplett - verhindert Zoom durch das Plugin
                    e.preventDefault();
                    e.stopPropagation();

                    // Normalisiere delta für sanftes Scrollen
                    const normalizedDelta = Math.sign(e.deltaX) * Math.min(Math.abs(e.deltaX) / 100, 1);

                    // Pan in Pixeln - ca. 50 Pixel pro Scroll-Schritt
                    const pixelAmount = normalizedDelta * 50;

                    // Wende Pan an (negative Werte = nach links, positive = nach rechts)
                    chart.pan({ x: -pixelAmount }, undefined, 'default');

                    // Callback nach dem Pan aufrufen (für dynamische Neuberechnung)
                    if (onPanCallback) {
                        onPanCallback();
                    }
                }
                // deltaY (Mausrad drehen) wird nicht gestoppt -> geht zum Zoom-Plugin
            }, { passive: false, capture: true });
        }

        const DATA_URL = './performance_analyse.json';
        const OVERVIEW_URL = '../overview.json';
        async function loadJSONData(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP Fehler ${response.status}`);
            return response.json();
        }
        function updateLastUpdate(timestamp, elementId = 'last-update') {
            if (!timestamp) return;
            const el = document.getElementById(elementId);
            if (el) el.innerHTML = `Letzte Aktualisierung: ${new Date(timestamp).toLocaleString('de-DE')}`;
        }
        function parseDate(str) {
            if (!str) return null;
            return new Date(str.replace(' ', 'T'));
        }
        let accountValueChart, accountPctChart, deltaCompareChart, costsChart, pnlChart, performanceChart;
        let fullHistory = [], fullPerfData = null, fullPnlChartData = [], fullTransactions = [];
        let sortedChartData = []; // Sortierte Daten für dynamische Neuberechnung
        let sortedPerformanceData = { history: [] }; // Für Performance-Chart dynamische Neuberechnung - alle Daten aus history

        // Funktion um Performance-Chart basierend auf sichtbarem Bereich neu zu berechnen
        function recalculatePerformanceFromVisibleRange() {
            if (!performanceChart || sortedPerformanceData.history.length === 0) return;

            const xScale = performanceChart.scales.x;
            if (!xScale) return;

            const visibleMin = xScale.min;

            // Finde ersten sichtbaren Datenpunkt in History
            let startIdx = 0;
            for (let i = 0; i < sortedPerformanceData.history.length; i++) {
                const dataTime = parseDate(sortedPerformanceData.history[i].datum).getTime();
                if (dataTime >= visibleMin) {
                    startIdx = i;
                    break;
                }
            }

            // Kumuliere Realized P&L Net ab dem sichtbaren Startpunkt
            let cumNet = 0;
            const newRealizedData = sortedPerformanceData.history.map((h, idx) => {
                if (idx >= startIdx) {
                    cumNet += h.realized_pnl_net || 0;
                }
                return {
                    x: parseDate(h.datum),
                    y: idx >= startIdx ? cumNet : 0
                };
            });

            // Transaktionskosten ab sichtbarem Startpunkt
            const startCosts = sortedPerformanceData.history.length > 0 && startIdx < sortedPerformanceData.history.length ?
                ((sortedPerformanceData.history[startIdx].kosten_kumulativ || 0) +
                 (sortedPerformanceData.history[startIdx].slippage_kumulativ || 0)) : 0;

            const newCostsData = sortedPerformanceData.history.map((h, idx) => {
                if (idx >= startIdx) {
                    const totalCost = (h.kosten_kumulativ || 0) + (h.slippage_kumulativ || 0) - startCosts;
                    return {
                        x: parseDate(h.datum),
                        y: -totalCost
                    };
                }
                return {
                    x: parseDate(h.datum),
                    y: 0
                };
            });

            // Unrealized P&L (Snapshot-Werte, nicht kumulativ) - null beibehalten für Index-Synchronisation
            const unrealizedData = sortedPerformanceData.history.map(h => ({
                x: parseDate(h.datum),
                y: h.unrealized_pnl !== null && h.unrealized_pnl !== undefined ? h.unrealized_pnl : null
            }));

            // Performance (Summe) berechnen
            const performanceData = sortedPerformanceData.history.map((h, idx) => {
                const unrealized = h.unrealized_pnl || 0;
                const realized = idx >= startIdx ? newRealizedData[idx].y : 0;
                const costs = idx >= startIdx ? newCostsData[idx].y : 0;
                return {
                    x: parseDate(h.datum),
                    y: unrealized + realized + costs
                };
            });

            // Update Chart-Daten
            performanceChart.data.datasets[0].data = performanceData;
            performanceChart.data.datasets[1].data = unrealizedData;
            performanceChart.data.datasets[2].data = newRealizedData;
            performanceChart.data.datasets[3].data = newCostsData;
            performanceChart.update('none');
        }

        // Funktion um Performance-Daten basierend auf sichtbarem Bereich neu zu berechnen
        function recalculatePctFromVisibleRange() {
            if (!accountPctChart || sortedChartData.length === 0) return;

            const xScale = accountPctChart.scales.x;
            if (!xScale) return;

            const visibleMin = xScale.min;

            // Finde den ersten sichtbaren Datenpunkt
            let startIdx = 0;
            for (let i = 0; i < sortedChartData.length; i++) {
                const dataTime = parseDate(sortedChartData[i].datum).getTime();
                if (dataTime >= visibleMin) {
                    startIdx = i;
                    break;
                }
            }

            const startEntry = sortedChartData[startIdx];
            const startValue = startEntry.konto_wert;
            const startMesPreis = startEntry.mes_preis || 0;

            // Berechne neue Prozent-Werte relativ zum sichtbaren Start
            const newStrategyData = sortedChartData.map(h => ({
                x: parseDate(h.datum),
                y: ((h.konto_wert - startValue) / startValue * 100)
            }));

            const newBuyHoldData = sortedChartData.map(h => ({
                x: parseDate(h.datum),
                y: startMesPreis > 0 ? (((h.mes_preis || 0) - startMesPreis) / startMesPreis * 100) : 0
            }));

            // Update Chart-Daten
            accountPctChart.data.datasets[0].data = newStrategyData;
            accountPctChart.data.datasets[1].data = newBuyHoldData;
            accountPctChart.update('none');
        }

        async function loadData() {
            try {
                const data = await loadJSONData(DATA_URL);
                const perfData = data.performance_data;
                if (perfData) {
                    fullHistory = perfData.history || [];
                    fullPerfData = perfData;
                    updateMetrics(perfData);
                    const today = new Date().toISOString().split('T')[0];
                    const dateFilterTo = document.getElementById('dateFilterTo');
                    if (dateFilterTo && !dateFilterTo.value) dateFilterTo.value = today;
                    applyUnifiedFilter();
                    updateTable(perfData.history);
                }
                updateLastUpdate(data.timestamp);
                try {
                    const overviewData = await loadJSONData(OVERVIEW_URL);
                    if (overviewData.realized_pnl_chart && overviewData.realized_pnl_chart.length > 0) {
                        fullPnlChartData = overviewData.realized_pnl_chart;
                        initPnlChart(fullPnlChartData);
                        applyUnifiedFilter();
                    }
                    if (overviewData.recent_transactions && overviewData.recent_transactions.length > 0) {
                        fullTransactions = overviewData.recent_transactions;
                        updateTransactionsTable(overviewData.recent_transactions);
                    }
                    // Performance Chart initialisieren - nur mit history aus performance_analyse.json
                    if (fullHistory.length > 0) {
                        initPerformanceChart(fullHistory);
                    }
                } catch (e) { console.warn('Konnte P&L Chart-Daten nicht laden:', e); }
            } catch (error) { console.error('Fehler:', error); }
        }


        function applyUnifiedFilter() {
            const fromDateInput = document.getElementById('dateFilterFrom');
            const toDateInput = document.getElementById('dateFilterTo');

            if (!fromDateInput || fullHistory.length === 0) return;

            const fromDate = fromDateInput.value;
            const toDate = toDateInput.value;

            let filteredHistory;
            if (!fromDate) {
                filteredHistory = fullHistory;
            } else {
                filteredHistory = fullHistory.filter(h => {
                    const recordDate = h.datum.substring(0, 10);
                    if (recordDate < fromDate) return false;
                    if (toDate && recordDate > toDate) return false;
                    return true;
                });
            }

            if (filteredHistory.length === 0) return;

            // Sortiere nach Datum um den zeitlich ersten Eintrag zu finden
            const sortedFiltered = [...filteredHistory].sort((a, b) => parseDate(a.datum) - parseDate(b.datum));
            const startEntry = sortedFiltered[0];
            const startValue = startEntry.konto_wert;
            const startMesPreis = startEntry.mes_preis || 0;
            const startCosts = startEntry.kosten_kumulativ || 0, startSlippage = startEntry.slippage_kumulativ || 0;
            const recalculatedHistory = filteredHistory.map(h => ({
                ...h,
                konto_wert_pct: ((h.konto_wert - startValue) / startValue * 100),
                buy_hold_pct: startMesPreis > 0 ? (((h.mes_preis || 0) - startMesPreis) / startMesPreis * 100) : 0,
                kosten_kumulativ: (h.kosten_kumulativ || 0) - startCosts,
                slippage_kumulativ: (h.slippage_kumulativ || 0) - startSlippage,
                total_kosten_kumulativ: ((h.kosten_kumulativ || 0) - startCosts) + ((h.slippage_kumulativ || 0) - startSlippage),
                kosten_pro_kontrakt: h.kosten_pro_kontrakt,
                slippage_pro_kontrakt: h.slippage_pro_kontrakt,
                total_kosten_pro_kontrakt: h.total_kosten_pro_kontrakt,
                neuer_hebel: h.neuer_hebel
            }));
            updateCharts(recalculatedHistory);
            if (pnlChart && fullPnlChartData.length > 0) {
                let filteredPnlData;
                if (!fromDate) {
                    filteredPnlData = fullPnlChartData;
                } else {
                    filteredPnlData = fullPnlChartData.filter(d => {
                        if (d.date < fromDate) return false;
                        if (toDate && d.date > toDate) return false;
                        return true;
                    });
                }
                let cumGross = 0, cumNet = 0;
                const recalcPnl = filteredPnlData.map(d => {
                    cumGross += d.daily_gross || 0;
                    cumNet += d.daily_net || 0;
                    return { ...d, cumulative_gross: cumGross, cumulative_net: cumNet };
                });
                pnlChart.data.datasets[0].data = recalcPnl.map(d => ({ x: parseDate(d.date), y: d.cumulative_gross }));
                pnlChart.data.datasets[1].data = recalcPnl.map(d => ({ x: parseDate(d.date), y: d.cumulative_net }));
                pnlChart.update();

            }

            // Performance Chart aktualisieren - alle Daten aus recalculatedHistory
            if (performanceChart && recalculatedHistory.length > 0) {
                // Sortiere nach Datum
                const sortedHistory = [...recalculatedHistory].sort((a, b) => parseDate(a.datum) - parseDate(b.datum));

                // Kumulative Werte neu berechnen ab Filterstart
                let cumRealizedNet = 0;
                let cumCosts = 0;
                const recalcHistory = sortedHistory.map(h => {
                    cumRealizedNet += h.realized_pnl_net || 0;
                    cumCosts += (h.kosten_pro_kontrakt || 0) + (h.slippage_pro_kontrakt || 0);
                    return {
                        ...h,
                        cumulative_realized_net_recalc: cumRealizedNet,
                        cumulative_costs_recalc: (h.kosten_kumulativ || 0) + (h.slippage_kumulativ || 0)
                    };
                });

                // Speichere für dynamische Neuberechnung
                sortedPerformanceData.history = recalcHistory;

                // Startkosten für Offset
                const startCosts = recalcHistory.length > 0 ? recalcHistory[0].cumulative_costs_recalc : 0;

                // Unrealized: null beibehalten für Index-Synchronisation beim Hover
                const unrealizedData = recalcHistory.map(h => ({
                    x: parseDate(h.datum),
                    y: h.unrealized_pnl !== null && h.unrealized_pnl !== undefined ? h.unrealized_pnl : null
                }));

                const realizedPnlData = recalcHistory.map(h => ({
                    x: parseDate(h.datum),
                    y: h.cumulative_realized_net_recalc
                }));

                const costsData = recalcHistory.map(h => ({
                    x: parseDate(h.datum),
                    y: -(h.cumulative_costs_recalc - startCosts)
                }));

                // Performance (Summe) berechnen
                const performanceSumData = recalcHistory.map(h => {
                    const unrealized = h.unrealized_pnl || 0;
                    const realized = h.cumulative_realized_net_recalc;
                    const costs = -(h.cumulative_costs_recalc - startCosts);
                    return {
                        x: parseDate(h.datum),
                        y: unrealized + realized + costs
                    };
                });

                performanceChart.data.datasets[0].data = performanceSumData;
                performanceChart.data.datasets[1].data = unrealizedData;
                performanceChart.data.datasets[2].data = realizedPnlData;
                performanceChart.data.datasets[3].data = costsData;
                performanceChart.update();
            }
        }
        function resetUnifiedFilter() {
            const fromDateInput = document.getElementById('dateFilterFrom');
            const toDateInput = document.getElementById('dateFilterTo');
            if (fromDateInput) fromDateInput.value = '2025-11-28';
            if (toDateInput) toDateInput.value = new Date().toISOString().split('T')[0];
            applyUnifiedFilter();
        }
        function formatCurrency(num, decimals = 0) {
            if (num === null || num === undefined) return '—';
            return new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'USD', minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(num);
        }
        function initPnlChart(chartData) {
            fullPnlChartData = chartData;
            const ctx = document.getElementById('pnlChart');
            if (!ctx) return;
            if (pnlChart) pnlChart.destroy();
            pnlChart = new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                        { label: 'Realized P&L Gross (Kumulativ)', data: chartData.map(d => ({ x: parseDate(d.date), y: d.cumulative_gross })), borderColor: '#3b82f6', backgroundColor: 'rgba(59, 130, 246, 0.1)', fill: true, tension: 0, pointRadius: 2, pointHoverRadius: 6 },
                        { label: 'Realized P&L Net (Kumulativ)', data: chartData.map(d => ({ x: parseDate(d.date), y: d.cumulative_net })), borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.1)', fill: true, tension: 0, pointRadius: 2, pointHoverRadius: 6 }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: { callbacks: { title: ctx => new Date(ctx[0].parsed.x).toLocaleDateString('de-DE'), label: ctx => `${ctx.dataset.label}: ${formatCurrency(ctx.parsed.y, 2)}` } },
                        zoom: zoomOptions
                    },
                    scales: {
                        x: { type: 'time', time: { displayFormats: { day: 'dd.MM.yy', hour: 'dd.MM HH:mm' }, tooltipFormat: 'dd.MM.yyyy HH:mm:ss' }, grid: { display: false } },
                        y: { ticks: { callback: v => '$' + v.toLocaleString('de-DE') }, grid: { color: 'rgba(0, 0, 0, 0.05)' } }
                    }
                }
            });

            // Doppelklick zum Reset
            ctx.ondblclick = () => pnlChart?.resetZoom();
            setupWheelPan(pnlChart);
        }
        function initPerformanceChart(history) {
            const ctx = document.getElementById('performanceChart');
            if (!ctx) return;
            if (performanceChart) performanceChart.destroy();

            // Sortierte Daten für dynamische Neuberechnung speichern - alle aus history
            sortedPerformanceData.history = [...history].sort((a, b) => parseDate(a.datum) - parseDate(b.datum));

            // Alle Daten kommen jetzt aus derselben Quelle (history)
            // Jeder Eintrag hat: unrealized_pnl, cumulative_realized_gross, kosten_kumulativ, slippage_kumulativ
            // WICHTIG: Alle Datasets müssen dieselben X-Werte haben für korrektes Hover-Verhalten

            // Unrealized: null-Werte beibehalten (nicht filtern!), damit Index synchron bleibt
            const unrealizedData = sortedPerformanceData.history.map(h => ({
                x: parseDate(h.datum),
                y: h.unrealized_pnl !== null && h.unrealized_pnl !== undefined ? h.unrealized_pnl : null
            }));

            const realizedPnlData = sortedPerformanceData.history.map(h => ({
                x: parseDate(h.datum),
                y: h.cumulative_realized_gross || 0
            }));

            const costsData = sortedPerformanceData.history.map(h => ({
                x: parseDate(h.datum),
                y: -((h.kosten_kumulativ || 0) + (h.slippage_kumulativ || 0))
            }));

            // Performance (Summe) berechnen: Unrealized + Realized + Kosten (pro Eintrag)
            const performanceSumData = sortedPerformanceData.history.map(h => {
                const unrealized = h.unrealized_pnl || 0;
                const realized = h.cumulative_realized_gross || 0;
                const costs = -((h.kosten_kumulativ || 0) + (h.slippage_kumulativ || 0));
                return {
                    x: parseDate(h.datum),
                    y: unrealized + realized + costs
                };
            });

            // Zoom-Optionen mit onPan-Callback für dynamische Neuberechnung
            const zoomOptionsPerformance = {
                pan: {
                    enabled: true,
                    mode: 'x',
                    threshold: 5,
                    onPan: function() {
                        recalculatePerformanceFromVisibleRange();
                    }
                },
                zoom: {
                    wheel: { enabled: true }, // Mausrad-Zoom aktiviert (deltaY)
                    pinch: { enabled: true },
                    drag: { enabled: false },
                    mode: 'x',
                    onZoom: function() {
                        recalculatePerformanceFromVisibleRange();
                    }
                },
                limits: {
                    x: { minRange: 86400000 }
                }
            };

            performanceChart = new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Performance (Summe)',
                            data: performanceSumData,
                            borderColor: '#0066cc',
                            backgroundColor: 'rgba(0, 102, 204, 0.1)',
                            fill: false,
                            tension: 0,
                            pointRadius: 3,
                            pointHoverRadius: 6,
                            borderWidth: 3
                        },
                        {
                            label: 'Unrealized P&L',
                            data: unrealizedData,
                            borderColor: '#8b5cf6',
                            backgroundColor: 'rgba(139, 92, 246, 0.1)',
                            fill: true,
                            tension: 0,
                            pointRadius: 3,
                            pointHoverRadius: 6,
                            borderWidth: 2,
                            spanGaps: false // null-Werte nicht verbinden
                        },
                        {
                            label: 'Kumulativ Realized P&L Net',
                            data: realizedPnlData,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            fill: true,
                            tension: 0,
                            pointRadius: 3,
                            pointHoverRadius: 6,
                            borderWidth: 2
                        },
                        {
                            label: 'Kumulativ Transaktionskosten',
                            data: costsData,
                            borderColor: '#f87171',
                            backgroundColor: 'rgba(248, 113, 113, 0.1)',
                            fill: true,
                            tension: 0,
                            pointRadius: 3,
                            pointHoverRadius: 6,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            filter: (tooltipItem) => tooltipItem.parsed.y !== null, // null-Werte ausblenden
                            callbacks: {
                                title: ctx => new Date(ctx[0].parsed.x).toLocaleDateString('de-DE'),
                                label: ctx => `${ctx.dataset.label}: ${formatCurrency(ctx.parsed.y, 2)}`
                            }
                        },
                        zoom: zoomOptionsPerformance
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { displayFormats: { day: 'dd.MM.yy', hour: 'dd.MM HH:mm' }, tooltipFormat: 'dd.MM.yyyy HH:mm:ss' },
                            grid: { display: false }
                        },
                        y: {
                            ticks: { callback: v => '$' + v.toLocaleString('de-DE') },
                            grid: { color: 'rgba(0, 0, 0, 0.05)' }
                        }
                    }
                }
            });

            ctx.ondblclick = () => {
                performanceChart?.resetZoom();
                // Nach Reset: Neuberechnung mit Original-Startpunkt
                setTimeout(recalculatePerformanceFromVisibleRange, 50);
            };
            setupWheelPan(performanceChart, recalculatePerformanceFromVisibleRange);
        }
        function updateMetrics(perfData) {
            if (!perfData) return;
            const metricsEl = document.getElementById('metrics');
            if (!metricsEl) return;
            const returnPct = parseFloat(perfData.total_return_pct || 0);
            const returnClass = returnPct >= 0 ? 'positive' : 'negative';
            const ibIndicator = perfData.current_value_from_ib ? '<span style="font-size: 10px; color: #4ade80; margin-left: 5px;">● IB</span>' : '<span style="font-size: 10px; color: #999; margin-left: 5px;">● DB</span>';
            metricsEl.innerHTML = `
                <div class="stat-card"><div class="stat-number">${formatCurrency(perfData.start_value)}</div><div class="stat-label">Startwert</div></div>
                <div class="stat-card"><div class="stat-number">${formatCurrency(perfData.current_value)}${ibIndicator}</div><div class="stat-label">Aktueller Wert</div></div>
                <div class="stat-card"><div class="stat-number ${returnClass}">${returnPct >= 0 ? '+' : ''}${returnPct.toFixed(2)}%</div><div class="stat-label">Rendite</div></div>
                <div class="stat-card"><div class="stat-number negative">${formatCurrency(perfData.total_costs)}</div><div class="stat-label">Kum. Kosten</div></div>
                <div class="stat-card"><div class="stat-number negative">${formatCurrency(perfData.total_slippage)}</div><div class="stat-label">Kum. Slippage</div></div>`;
        }

        // Funktion um synchronisiertes Hover zu handhaben
        function setupSyncedHover(chart) {
            chart.canvas.addEventListener('mousemove', (e) => {
                const rect = chart.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const xScale = chart.scales.x;
                if (x >= xScale.left && x <= xScale.right) {
                    currentHoverX = xScale.getValueForPixel(x);
                    syncedCharts.forEach(c => {
                        if (c !== chart) c.update('none');
                    });
                }
            });
            chart.canvas.addEventListener('mouseleave', () => {
                currentHoverX = null;
                syncedCharts.forEach(c => c.update('none'));
            });
        }

        function updateCharts(history) {
            if (!history || history.length === 0) return;
            const sorted = [...history].sort((a, b) => parseDate(a.datum) - parseDate(b.datum));
            sortedChartData = sorted; // Speichere für dynamische Neuberechnung
            const timeOpts = { type: 'time', time: { displayFormats: { day: 'dd.MM.yy', hour: 'dd.MM HH:mm' }, tooltipFormat: 'dd.MM.yyyy HH:mm:ss' }, grid: { color: '#f0f0f0' } };

            // Reset synced charts array
            syncedCharts = [];

            // Chart 1: Konto-Wert absolut
            const ctx1 = document.getElementById('accountValueChart').getContext('2d');
            if (accountValueChart) accountValueChart.destroy();
            accountValueChart = new Chart(ctx1, {
                type: 'line',
                data: { datasets: [{ label: 'Konto-Wert (USD)', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.konto_wert })), borderColor: '#0066cc', backgroundColor: 'rgba(0, 102, 204, 0.1)', fill: true, tension: 0, pointRadius: 4, pointHoverRadius: 8, pointBackgroundColor: '#0066cc' }] },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'top' }, zoom: zoomOptions }, scales: { x: timeOpts, y: { grid: { color: '#f0f0f0' }, ticks: { callback: v => '$' + (v/1000).toFixed(0) + 'k' } } } }
            });
            document.getElementById('accountValueChart').ondblclick = () => accountValueChart?.resetZoom();
            setupWheelPan(accountValueChart);

            // Chart 2: Konto-Wert % mit integriertem Hebel auf sekundärer Y-Achse
            const ctx2 = document.getElementById('accountPctChart').getContext('2d');
            if (accountPctChart) accountPctChart.destroy();
            const lastPct = sorted[sorted.length - 1].konto_wert_pct;

            // Hebel-Daten um t+1 verschieben: Der Hebel von t wird bei t+1 angezeigt
            // WICHTIG: Gleiche X-Werte wie andere Datasets für korrektes Hover-Verhalten
            const hebelDataShifted = sorted.map((h, idx) => {
                // Erster Punkt hat keinen Vorgänger-Hebel
                if (idx === 0) {
                    return { x: parseDate(h.datum), y: null };
                }
                // Hebel vom vorherigen Zeitpunkt (t-1)
                const prevHebel = sorted[idx - 1].neuer_hebel;
                return { x: parseDate(h.datum), y: prevHebel };
            });

            // Plugin für horizontale Referenzlinie bei Hebel 1.0x auf der y1 Achse
            const hebelRefLinePlugin = {
                id: 'hebelRefLine',
                afterDraw: (chart) => {
                    const yScale = chart.scales.y1;
                    if (!yScale) return;
                    const ctx = chart.ctx;
                    const y = yScale.getPixelForValue(1.0);
                    if (y >= yScale.top && y <= yScale.bottom) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(chart.chartArea.left, y);
                        ctx.lineTo(chart.chartArea.right, y);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
                        ctx.setLineDash([3, 3]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            };

            accountPctChart = new Chart(ctx2, {
                type: 'line',
                plugins: [hebelRefLinePlugin],
                data: { datasets: [
                    {
                        label: 'Strategie (%)',
                        data: sorted.map(h => ({ x: parseDate(h.datum), y: h.konto_wert_pct })),
                        borderColor: '#0066cc',
                        backgroundColor: 'rgba(0, 102, 204, 0.1)',
                        fill: true,
                        tension: 0,
                        pointRadius: 4,
                        pointHoverRadius: 8,
                        borderWidth: 2,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Buy & Hold MES (%)',
                        data: sorted.map(h => ({ x: parseDate(h.datum), y: h.buy_hold_pct || 0 })),
                        borderColor: '#f97316',
                        backgroundColor: 'rgba(249, 115, 22, 0.1)',
                        fill: false,
                        tension: 0,
                        pointRadius: 3,
                        pointHoverRadius: 7,
                        borderWidth: 2,
                        borderDash: [5, 5],
                        yAxisID: 'y'
                    },
                    {
                        label: 'Hebel (t-1)',
                        data: hebelDataShifted,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.15)',
                        fill: true,
                        tension: 0,
                        pointRadius: 2,
                        pointHoverRadius: 5,
                        borderWidth: 2,
                        yAxisID: 'y1',
                        spanGaps: false // null-Werte nicht verbinden
                    }
                ] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { position: 'top' },
                        zoom: zoomOptionsPct,
                        tooltip: {
                            filter: (tooltipItem) => tooltipItem.parsed.y !== null, // null-Werte ausblenden
                            callbacks: {
                                label: (context) => {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    if (label.includes('Hebel')) {
                                        return `${label}: ${value.toFixed(3)}x`;
                                    }
                                    return `${label}: ${value.toFixed(2)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: timeOpts,
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: { color: '#f0f0f0' },
                            ticks: { callback: v => v.toFixed(2) + '%' },
                            title: { display: true, text: 'Performance (%)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: { drawOnChartArea: false },
                            ticks: { callback: v => v.toFixed(2) + 'x' },
                            title: { display: true, text: 'Hebel' }
                        }
                    }
                }
            });
            document.getElementById('accountPctChart').ondblclick = () => {
                accountPctChart?.resetZoom();
                // Nach Reset: Neuberechnung mit Original-Startpunkt
                setTimeout(recalculatePctFromVisibleRange, 50);
            };
            setupWheelPan(accountPctChart, recalculatePctFromVisibleRange);

            syncedCharts.push(accountPctChart);
            setupSyncedHover(accountPctChart);

            // Chart 4: Delta Vergleich - Δ Konto vs Δ MES × Hebel
            const ctx4Compare = document.getElementById('deltaCompareChart').getContext('2d');
            if (deltaCompareChart) deltaCompareChart.destroy();

            // Berechne Δ Konto, Δ MES × Hebel und Differenz
            const deltaData = sorted.map((h, idx) => {
                if (idx === 0) return null;

                const prev = sorted[idx - 1];
                const prevKonto = prev.konto_wert || 0;
                const currKonto = h.konto_wert || 0;
                const prevMes = prev.mes_preis || 0;
                const currMes = h.mes_preis || 0;
                const hebel = prev.neuer_hebel || 0; // Hebel t-1

                const deltaKontoPct = prevKonto !== 0 ? ((currKonto - prevKonto) / prevKonto * 100) : 0;
                const deltaMesPct = prevMes !== 0 ? ((currMes - prevMes) / prevMes * 100) : 0;
                const deltaMesHebelPct = deltaMesPct * hebel;
                const differenz = deltaKontoPct - deltaMesHebelPct;

                return {
                    x: parseDate(h.datum),
                    deltaKonto: deltaKontoPct,
                    deltaMesHebel: deltaMesHebelPct,
                    differenz: differenz
                };
            }).filter(d => d !== null);

            deltaCompareChart = new Chart(ctx4Compare, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Δ Konto (%)',
                            data: deltaData.map(d => ({ x: d.x, y: d.deltaKonto })),
                            borderColor: '#0066cc',
                            backgroundColor: 'rgba(0, 102, 204, 0.1)',
                            fill: false,
                            tension: 0,
                            pointRadius: 3,
                            borderWidth: 2,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Δ MES × Hebel (%)',
                            data: deltaData.map(d => ({ x: d.x, y: d.deltaMesHebel })),
                            borderColor: '#f97316',
                            backgroundColor: 'rgba(249, 115, 22, 0.1)',
                            fill: false,
                            tension: 0,
                            pointRadius: 3,
                            borderWidth: 2,
                            borderDash: [5, 5],
                            yAxisID: 'y'
                        },
                        {
                            label: 'Differenz (%)',
                            data: deltaData.map(d => ({ x: d.x, y: d.differenz })),
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.2)',
                            fill: true,
                            tension: 0,
                            pointRadius: 2,
                            borderWidth: 2,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { position: 'top' },
                        zoom: zoomOptions,
                        tooltip: {
                            callbacks: {
                                label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(4)}%`
                            }
                        }
                    },
                    scales: {
                        x: timeOpts,
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: { color: '#f0f0f0' },
                            ticks: { callback: v => v.toFixed(2) + '%' },
                            title: { display: true, text: 'Δ Konto / Δ MES×Hebel' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: { drawOnChartArea: false },
                            ticks: { callback: v => v.toFixed(2) + '%' },
                            title: { display: true, text: 'Differenz' }
                        }
                    }
                }
            });
            document.getElementById('deltaCompareChart').ondblclick = () => deltaCompareChart?.resetZoom();
            setupWheelPan(deltaCompareChart);
            syncedCharts.push(deltaCompareChart);
            setupSyncedHover(deltaCompareChart);

            // Chart 5: Kosten
            const ctx5 = document.getElementById('costsChart').getContext('2d');
            if (costsChart) costsChart.destroy();
            costsChart = new Chart(ctx5, {
                type: 'line',
                data: { datasets: [
                    { label: 'Transaktionskosten / Kontrakt', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.kosten_pro_kontrakt })).filter(p => p.y > 0), borderColor: '#f87171', backgroundColor: 'rgba(248, 113, 113, 0.1)', fill: true, tension: 0, pointRadius: 3, pointHoverRadius: 7 },
                    { label: 'Slippage / Kontrakt', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.slippage_pro_kontrakt })).filter(p => p.y > 0), borderColor: '#fbbf24', backgroundColor: 'rgba(251, 191, 36, 0.1)', fill: true, tension: 0, pointRadius: 3, pointHoverRadius: 7 },
                    { label: 'Total / Kontrakt', data: sorted.map(h => ({ x: parseDate(h.datum), y: h.total_kosten_pro_kontrakt })).filter(p => p.y > 0), borderColor: '#8b5cf6', borderWidth: 2, borderDash: [5, 5], fill: false, tension: 0, pointRadius: 4, pointHoverRadius: 8 }
                ] },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'top' }, zoom: zoomOptions }, scales: { x: timeOpts, y: { grid: { color: '#f0f0f0' }, ticks: { callback: v => '$' + v.toFixed(2) } } } }
            });
            document.getElementById('costsChart').ondblclick = () => costsChart?.resetZoom();
            setupWheelPan(costsChart);
        }

        function updateTable(history) {
            const tbody = document.querySelector('#history-table tbody');
            if (!history || history.length === 0) { tbody.innerHTML = '<tr><td colspan="13" style="text-align:center">Keine Daten</td></tr>'; return; }
            const reversed = [...history].reverse();
            tbody.innerHTML = reversed.map((h, idx) => {
                const hebel = h.neuer_hebel !== null && h.neuer_hebel !== undefined ? h.neuer_hebel.toFixed(3) + 'x' : '—';
                const kostenProKontraktVal = h.kosten_pro_kontrakt > 0 ? h.kosten_pro_kontrakt : 0;
                const slippageProKontraktVal = h.slippage_pro_kontrakt > 0 ? h.slippage_pro_kontrakt : 0;
                const totalProKontraktVal = kostenProKontraktVal + slippageProKontraktVal;
                const kostenProKontrakt = kostenProKontraktVal > 0 ? '$' + kostenProKontraktVal.toFixed(3) : '—';
                const slippageProKontrakt = slippageProKontraktVal > 0 ? '$' + slippageProKontraktVal.toFixed(3) : '—';
                const totalProKontrakt = totalProKontraktVal > 0 ? '$' + totalProKontraktVal.toFixed(3) : '—';
                const mesPreis = h.mes_preis ? '$' + h.mes_preis.toFixed(2) : '—';

                // Berechne Deltas
                let deltaKonto = '—', deltaMes = '—', deltaMesHebel = '—', differenz = '—', diffKonto = '—';
                let deltaKontoClass = '', deltaMesClass = '', deltaMesHebelClass = '', differenzClass = '', diffKontoClass = '';
                let deltaKontoPctVal = 0, deltaMesPctVal = 0, deltaMesHebelPctVal = 0, differenzVal = 0;

                // Wir brauchen den zeitlich früheren Wert (nächster in reversed array)
                if (idx < reversed.length - 1) {
                    const prev = reversed[idx + 1]; // Zeitlich früher
                    const prevKonto = prev.konto_wert || 0;
                    const currKonto = h.konto_wert || 0;
                    const prevMes = prev.mes_preis || 0;
                    const currMes = h.mes_preis || 0;
                    const prevHebel = prev.neuer_hebel || 0; // Hebel t-1 für Berechnung

                    if (prevKonto > 0) {
                        deltaKontoPctVal = ((currKonto - prevKonto) / prevKonto * 100);
                        deltaKontoClass = deltaKontoPctVal >= 0 ? 'positive' : 'negative';
                        deltaKonto = (deltaKontoPctVal >= 0 ? '+' : '') + deltaKontoPctVal.toFixed(2) + '%';
                    }

                    if (prevMes > 0) {
                        deltaMesPctVal = ((currMes - prevMes) / prevMes * 100);
                        deltaMesClass = deltaMesPctVal >= 0 ? 'positive' : 'negative';
                        deltaMes = (deltaMesPctVal >= 0 ? '+' : '') + deltaMesPctVal.toFixed(2) + '%';

                        // Δ MES × Hebel
                        deltaMesHebelPctVal = deltaMesPctVal * prevHebel;
                        deltaMesHebelClass = deltaMesHebelPctVal >= 0 ? 'positive' : 'negative';
                        deltaMesHebel = (deltaMesHebelPctVal >= 0 ? '+' : '') + deltaMesHebelPctVal.toFixed(2) + '%';
                    }

                    // Differenz = Δ Konto - Δ MES × Hebel
                    if (prevKonto > 0 && prevMes > 0) {
                        differenzVal = deltaKontoPctVal - deltaMesHebelPctVal;
                        differenzClass = differenzVal >= 0 ? 'positive' : 'negative';
                        differenz = (differenzVal >= 0 ? '+' : '') + differenzVal.toFixed(3) + '%';

                        // Differenz × Kontowert
                        const diffKontoVal = (differenzVal / 100) * currKonto;
                        diffKontoClass = diffKontoVal >= 0 ? 'positive' : 'negative';
                        diffKonto = formatCurrency(diffKontoVal, 2);
                    }
                }

                // Farbe für Total/Kontraktkurs: rot wenn > $0.38, orange wenn > $0.25
                const totalStyle = totalProKontraktVal > 0.38 ? 'class="negative"' : (totalProKontraktVal > 0.25 ? 'style="color: #f97316;"' : '');

                // Zeitslippage: positiv = grün (gut), negativ = rot (schlecht)
                const zeitslippageVal = h.zeitslippage;
                let zeitslippage = '—';
                let zeitslippageClass = '';
                if (zeitslippageVal !== null && zeitslippageVal !== undefined) {
                    zeitslippageClass = zeitslippageVal >= 0 ? 'positive' : 'negative';
                    zeitslippage = (zeitslippageVal >= 0 ? '+' : '') + '$' + Math.abs(zeitslippageVal).toFixed(3);
                }

                return `<tr><td>${h.datum}</td><td style="text-align:right">${formatCurrency(h.konto_wert)}</td><td style="text-align:right" class="${deltaKontoClass}">${deltaKonto}</td><td style="text-align:right">${mesPreis}</td><td style="text-align:right" class="${deltaMesClass}">${deltaMes}</td><td style="text-align:right">${hebel}</td><td style="text-align:right" class="${deltaMesHebelClass}">${deltaMesHebel}</td><td style="text-align:right" class="${differenzClass}">${differenz}</td><td style="text-align:right" class="${diffKontoClass}">${diffKonto}</td><td style="text-align:right">${kostenProKontrakt}</td><td style="text-align:right">${slippageProKontrakt}</td><td style="text-align:right" ${totalStyle}>${totalProKontrakt}</td><td style="text-align:right" class="${zeitslippageClass}">${zeitslippage}</td></tr>`;
            }).join('');
        }

        function updateTransactionsTable(transactions) {
            const tbody = document.querySelector('#transactions-table tbody');
            if (!transactions || transactions.length === 0) { tbody.innerHTML = '<tr><td colspan="9" style="text-align:center">Keine Transaktionen</td></tr>'; return; }
            tbody.innerHTML = transactions.map(t => {
                const formatPnlCell = (val) => {
                    if (val === null || val === undefined) return '—';
                    const num = parseFloat(val);
                    const cls = num >= 0 ? 'positive' : 'negative';
                    return `<span class="${cls}">${formatCurrency(num, 2)}</span>`;
                };
                return `<tr>
                    <td>${new Date(t.date_chi).toLocaleString('de-DE')}</td>
                    <td><strong>${t.aktion || '—'}</strong></td>
                    <td style="text-align:right">${t.ausgefuehrte_menge ?? '—'}</td>
                    <td style="text-align:right">${t.durchschnittspreis ? '$' + parseFloat(t.durchschnittspreis).toFixed(2) : '—'}</td>
                    <td style="text-align:right">${t.avg_position_cost_before ? '$' + parseFloat(t.avg_position_cost_before).toFixed(2) : '—'}</td>
                    <td style="text-align:right">${t.avg_position_cost ? '$' + parseFloat(t.avg_position_cost).toFixed(2) : '—'}</td>
                    <td style="text-align:right">${formatPnlCell(t.realized_pnl_gross)}</td>
                    <td style="text-align:right">${formatPnlCell(t.realized_pnl_net)}</td>
                    <td>${t.status || '—'}</td>
                </tr>`;
            }).join('');
        }
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('applyUnifiedFilter')?.addEventListener('click', applyUnifiedFilter);
            document.getElementById('resetUnifiedFilter')?.addEventListener('click', resetUnifiedFilter);
            document.getElementById('dateFilterFrom')?.addEventListener('change', applyUnifiedFilter);
            document.getElementById('dateFilterTo')?.addEventListener('change', applyUnifiedFilter);
            const toDateInput = document.getElementById('dateFilterTo');
            if (toDateInput && !toDateInput.value) toDateInput.value = new Date().toISOString().split('T')[0];
        });
        loadData();
        setInterval(loadData, 60000);

        // Initialize shared includes
        initIncludes({ activeNav: 'nav-dashboard', loadCSS: false });
    </script>
</body>
</html>
